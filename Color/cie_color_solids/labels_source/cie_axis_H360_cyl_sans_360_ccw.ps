%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.996 Copyright 2016 Radical Eye Software
%%Title: cie_axis_H360_cyl_sans_360_ccw.dvi
%%CreationDate: Mon Mar 27 19:54:42 2017
%%BoundingBox: 327 983 345 994
%%DocumentFonts: TeXGyreHeros-Italic TeXGyreHeros-Regular
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E cie_axis_H360_cyl_sans_360_ccw.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2017.03.27:1954
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: q-ec.enc 0 0
% This file belongs to the TeX Gyre collection of fonts. The work
% is released under the GUST Font License. See the respective
% MANIFEST*.txt and README*.txt files for the details.
% For the most recent version of this license see
% http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt or
% http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt
% 
% NOTE: all fonts of the TeX Gyre family share EXACTLY THE SAME
%       *.enc files.
/encqec[
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/cwm
/perthousandzero
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcedilla
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcedilla
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/Germandbls
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

/preview@version(11.89)def

userdict begin/preview-bop-level 0 def/bop-hook{/preview-bop-level
dup load dup 0 le{/isls false def/vsize 792 def/hsize 612 def}if 1
add store}bind def/eop-hook{/preview-bop-level dup load dup 0 gt{1
sub}if store}bind def end

/preview@tightpage true def (compatibility PostScript comment for dvipng<=1.5

userdict begin/bop-hook{7{currentfile token not{stop}if 65781.76 div
DVImag mul}repeat 72 add 72 2 copy gt{exch}if 4 2 roll neg 2 copy lt{exch}if
dup 0 gt{pop 0 exch}{exch dup 0 lt{pop 0}if}ifelse 720 add exch 720
add 3 1 roll 4{5 -1 roll add 4 1 roll}repeat <</PageSize[5 -1 roll
6 index sub 5 -1 roll 5 index sub]/PageOffset[7 -2 roll [1 1 dtransform
exch]{0 ge{neg}if exch}forall]>>setpagedevice//bop-hook exec}bind def
end

userdict (some extra code to avoid dvipng>=1.6 unknown special: 7{currentfile token not{stop}if 65781.76 div }))
pop

userdict begin/bop-hook{preview-bop-level 0 le{7{currentfile token
not{stop}if 65781.76 div DVImag mul}repeat 72 add 72 2 copy gt{exch}if
4 2 roll neg 2 copy lt{exch}if dup 0 gt{pop 0 exch}{exch dup 0 lt{pop
0}if}ifelse 720 add exch 720 add 3 1 roll 4{5 -1 roll add 4 1 roll}repeat
<</PageSize[5 -1 roll 6 index sub 5 -1 roll 5 index sub]/PageOffset[7
-2 roll [1 1 dtransform exch]{0 ge{neg}if exch}forall]>>setpagedevice}if//bop-hook
exec}bind def end
 
@fedspecial end
%%BeginFont: TeXGyreHeros-Regular
%!PS-AdobeFont-1.0: TeXGyreHeros-Regular 2.004
%%CreationDate: 30th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2007-2009 for TeX Gyre extensions by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS). Vietnamese characters were added by Han The Thanh.
% Supported by CSTUG, DANTE eV, GUST, NTG, TUG, and TUG India.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% See the MANIFEST-TeX-Gyre-Heros.txt and README-TeX-Gyre-Heros.txt
% files for the details. For the most recent version of this license see
% http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt or
% http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt
% This work has the LPPL maintenance status "maintained".
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-TeX-Gyre-Heros.txt file.
% ADL: 750 250 0
%%EndComments
FontDirectory/TeXGyreHeros-Regular known{/TeXGyreHeros-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2007-2009 for TeX Gyre extensions by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS). Vietnamese characters were added by Han The Thanh.)readonly def
/FullName(TeXGyreHeros-Regular)readonly def
/FamilyName(TeXGyreHeros)readonly def
/Weight(Regular)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -127 def
/UnderlineThickness 50 def
end readonly def
/FontName /TeXGyreHeros-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-529 -284 1353 1148}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E5D071F743ACDAD8F4F97A172EEF96CD19C387
97118EE84B1DE73DCFB30C43A09CE2A3521E3342CD8A7EE63604BB81EE843F5D
6AD3646FF6B479C52FD0C9FC52E579D169DFECA886FF0E54E262A6CC059780B8
AC3CDCF49E906FDA76481CB5BDB1EE6DC02FAE8CC73018E1E2E4939FD7A448EE
DA1471E895A46A74FBE50DD2437045EDAAF6B957FCCE96FB3A4DC9021D96DA27
37D731BEAF10DF6CFCC24D6803846690B4BBCB8E1928246165763D50FAF9B5F0
93509B91EEA25D7B61786D9F4149B36BEE51FBDDF7E06228C4160520E0CAF83F
0D487CF5C122EE41F6A380BB09A9AF33205EB05619612590B57CA08E10F50E6D
6788497E8CB96D357997D01E77B163EDA75101941204B0A17A198869010486C5
6F45AFC9ECF1666FF4841967CB52B750D8ECE0ED839C0F720157ABBB3C371B25
895A56518EAF5689FEFC290E491293E66D12DFB05DC83DB9565305C8FEC7928A
467537F3222D27267FB312C6AB3430C715BE4B86E51C0D1C01554F143E6B3979
F32F1DFD4E47C63BCE7014F6E563635DC0A4A57CA5E6905751357282DEDE9528
67D4D01E7C79921665F5947DFC2C1D6B49807609946C222F02953943687731D1
EAA95D6592D827EDFFE3FE5D442D67CD7771331F97B42CDC8E4A6A564C539ACC
1227C18ABEA0E2C2A0898F3B9C15EA9B371BC1F77554CDA108B85B92B4774F1F
377689E0AEC6EC07CA2D74E9E58093306584D6EC7950FB089B593F5CED7B0B17
89B42C88ECE9AC041895EC59812902863434670C6FDA455864B35B77D72585E9
CCF32C7B67B8A1D1CAEEA32A82F255A6BE9C34ED46BF41F89F50E672D7CEBC3F
1248D09F4C8EB7A49A12DDA1CB5DA154F9830BD7E3772FECF7E7C2800E043D50
5D72024179FFF4FF57258AA1144AC72102969E8F41F59AF4799BB4CA6F3650FE
C8D9C31E2A8368F07FA45CD08D793538F700E72F11EFABA6F523190E8FC3AF32
3ABAAD29FB47DA16FAC74CE8785BE8AD7C28808F0F56DB36AE92E92DEA1E67AE
4C299F921D810E01B53DC436D83BC9E65A75869BFBF77EA98E5F42616ACDFDB8
A83AE84F8ECCEC500BE721708B44A09610AFDCC3EEFFF46A496E7C77173A0C5A
48B9AA14B50E1295C517FC56B87F1FE515EB91C7FF331732E9DCC575ED942B90
C2DC1B8AE5989BF17241D48376766A1631F42AC0FC37D91B86475F3CC0C06329
4A1C509A5A29792615890E71699CD9BFABC86D8E92256042E3E88F696D4EBFE5
8F651270762287FAC65EB8AFA03089FB64A4276E5D5B346A716F28F87E3639D0
91922F4994671B22EFD41FF3F778B3A2F97270CF2AA8ECAFC79BBBDB66CE1C1A
4189DAB0784D0778A4244CAB95EF2FFC33D38B2479461E3CC0C0042B48793475
561AE2718C4742058FE118C6E74557BC27F73C857AA0BC3D5527C8A3FEE8D1DE
7642F3BD4C077811073FB73D34FE110BBDAAE3FEA85CCC376C94E2CD50F72FB1
F8FF9489F6D6DDA2E0629F34ED4756894A17497B27E9A8054D3D6B635926CB59
4E52CDCBB0BF96AE126C66B7EF67D7F0788071415B1E7A6CACA81F2477E7BD66
A4B803B7B4ED054CD81E02C40475CC3DA450615CE32FCBC1B02EA66BA63EC534
C60B61F1B410504077E639BFD624575BBD8F1BA49A25E227C1394953F6254E6A
4D3B38558C6287C81A6FCAD90C5684302DEA419D1F6A957DAFD77599C504C8B2
B7A6A708F9B4EDD10AFE529E542684F7EE03E3A023570BD17A6E4F1EB3E85EC2
F094AB06D427B5E1E7412B3369336B40040ED5D4B9E13A466FB2F8ECBC0C5201
9F55265AFAB01B4C39C37DE56BA2662E21344E73C74148C1EFCACC0DC5B4F326
8A8831F3391A7B2A17E1A8397AD52B05D403CD56EC5D3671C9CE091995D38449
1B65E4BFD1D4343512ADA1B78E710A10079F211FAA5227E067BD342E796FF285
F008E8815DC181F7BCB30C2775071693306E17DF2D9686FDF1F0122A886D3AD6
3FF125B825216A78E7C80CA7211010D2C00C5BFF35F8A3520BC4D4515FA04804
7C0B8A18D740CFE6981CB8B669CED436BEB2A4BE3681818F820B00324D5E6F6D
05CE21181170BB05CC2CAF62830C2C50EFD34C4EF059EFBBC70968AEFB7F45C8
502E8D315A417268C534604E61F1909488B3C1295FB381FFE037D9126BAEBC8D
2035A418CC45E254F6EE96724B8CEA4F4A9959E043132D4737DBC8CB8E548723
2F1EB4E76EC19851686E56301AE48959C0ABC289CDE655EC5D586D483DA69C31
6EAF067769C89D42F6F34DF5F59AC591E015E61428653AFD0B0E5186F6949A70
C40B3E6AAB5B0440DAB81C9E9A3EB75E31431F5620D96EEB8C55193AD8B67BF1
07CB781E2093B59BD4F441A42C82FFC652D3CD1924EBE44199949AF13E05EA2E
CB274ECC3FCCA3E01430531CAA841028DCD2ACA3094563790CC22C491F3A800A
39AC561D5ED025A2448EDA8A35B556426607357AF910C49850701AA5003DBE75
7D554390F2712677A332F3AF83E8680C4298BB02E8DF6E257FC4720A3A883C11
3C2E7A8DF0AB9C9B35E71B0BE1A3A7054D23B58BECD547D0B2CEE72323E53142
FF6442DD52B0E38314DF7F0434C9599D055D786DC25523AF3CDCDA8593896D46
439C74C71CE66F03C6FE287CC70F6FE8177DE1AB55FEA2AA4FB28CD56DAE1865
B46C21E0E19F4A69EF54FEF08241C7BD0291A1F80AEA1F88493ECECC0D1357BE
9CAA1126E0B29CCF37CA44199F828B1FC9CC925E6B4450D61534122A2BAFE84F
9E953A9066C874B4E7EE3A8A30DB997012FE16D28F724FFC7A168A96E280CF7D
E23EB8526813890F9C9E1A4FDA387996D6AE02AA5AA6382253CB2BA6EBCCFBC2
6B35B841EB97D8A5451711BCF10381381D3FDDBB3CB3324EE46A492EF0633D73
C071CEA58830A18AE1C56554ECEE1243E50DBE5DA38D700443A638FB7F35261F
2A0A31ED6E7DB302E9AC30AE90D2AE24504F2E921D25501188441FA40A6B018F
59C1DACCD2750021AA644B7E01099393336984A0495B5AFDFA147835FE0BCFC5
5B32B4CC1AA1F4E87F1F184F6819F4D26416C3F9BAF49F09E15CB4DF774A63C6
E75A7426A7632B8B4797A8181CBAE0109F23BE0E07C8963EA8991C881EEBFB90
082BDF6C594CCBD796BB15E26398DD34FAB24DCA5AD5AE374A72FB1B4098228F
B6D6B41F8FE51016A41B172DF7FDDDC3E32466F9F87266BBBDB50946432A483A
C3651A3B3D100EC7F458B977A9F37112DCFE34D997672CC2DDC0033D035B1D76
DC14C0E3A5055D73E5490F871BF400F4C41EF7E166A381E75A9E731920A6FE7D
6A08CD85F75F066456C470C3226274D60C73AC3330555065F649FE81E6B3B1E8
D0ECC21206BB80B2F90CEC089B5B2A64DC911A05B7D0FBD3BC15657FCA29877F
78FDCBD1529BDC6DA3B5973D236A4B73710E184AE2CB3B276FC7A03B593C2123
C513B4202A301C459840C2E6E1EF0FCFB0208C7A0645DC66CD18EE703BAD7942
9321A8F96E2E1F02AD70E2FDBEEE625BBE27336EE7DD39FE52747FFE5802597B
7E6B04B22D9AE3E12242E16E1E63B6E13345DA78BFA5AE30FA18D73CDE3CD408
714E8E7C016ED719D6A4D045FA24AD8BD0CFB4919689DC056AF826360AECF7C4
B350822CA03E05BCC93B20D730B43691E149409C10DB0715331B3DE412A2681B
E0218448DFEDF16CF2DA1B7481AAC927A063B9C5500FF2F234B79DC65856CA9A
6F6CBF21FF1136E5C76F823D29D35078412923DBB3A32176E0ED92308EA9E707
B012A05EDDED8C8CDD041599710924C4FCCC7A4BAC3D34E426D7D9D908236037
C83A7D2E9649FC597894BD722B4747A668824294DF0117464C4F155166BA36E2
A6FA8745C28178B036AC8106A2A029B39A5588DF79D2E11306BEB7FB0A5BAE6D
20FE922F2AD0FAD8B198DD4BBC90179FE9329D97AFDB3F1B6C426CC298540C14
41477B022F220DC7C268E2745F60354A739F6DDBB748D0B86F21F9497121887F
CE1770047BA88646BAA9D6F0E16636DA27AB6AA16C69A80F8B8EC1202C05C19A
EE115A46C49A663A888F88A9E132E0D1F9F1E4A0135C64145D44C0D9BDB91E39
2190E7463774DEDFC3928949F19EEE06C1A0E5BE179E3D0EE6FCB5F93AAA169C
140A332092187F94485C968479DA81DB90BA9AC4B9EAD70DAEAA43C5D1F96A5A
DDE484D87C9F161DFB8B5AA27428BD9B7EE532F45FE6CD98BE1291A01E67F2AD
B1429C4D93EEB6C7C34769FC0C6B40A341C5661CCCBA123B2C56BCA4F1724FD3
C64E1B66C0F151A964659C86241FE188A2B151D9D4FBA51E499C44FC6D534C88
64120F5EAC9AA09148F4B1118179748A71114A08C2E2C56EA5C8F822C5914111
44CE72E06B401D3E3E9BC28711ABCCCB06EB5A36E90C1F95286B0C5DBD9E3292
8D252C6E5DD599F32E60A1D5251D270D0D2D081FD0C48CB4B342B148AA93A8CB
D31ACE5D70E4A43CB3A0F8F46E7977789B19EE83C5BC35BFC48D8CD565397F69
738E533A2C71F469930F2967664F0D17A94A65D60D226DE3179B50B077DFD0DD
1901FB57909918D07EA767FF958748DFF2C4A2EC29E036A55D98AE4F2F7798E4
43F2756A7FC778190DD5AEEBEF9B6A034E133314CB51222951144A9A0BD2A972
5B047F2104126F64633EDC41F96D143D5539E15480FFA57A171D13C33D1BB81D
4C8B59BF72F1B61098EA4DBDDA6D7C1033099BB4F81CECD8CA6B5AEABF5BE3A3
6153EA88A797296F2FE302F23663DD3A832205E640375A9CAA5245667D057C95
F2CA95993E77D4D6E9C3BC741BDEF11A8D2A1DAF060116E3379AAB88E878D7CB
46A02F9EC1E7C10945EC34DCAF6612217D2A9D23D94203EDFEB2A8899B078698
314F08981397316E3E495391EF6C45BE6D1FB3F56C8F84A7A13CCCA4C150AFC5
8E38EC9F0B780C2988095FC3D498C0915BB7CF147A540E9DDD953DFD01CAEBA5
61F028611754F949BAACC0CCB2A074C78B92C8573750B91386CECD4A1243D6AB
03AE2DECA9ECDE88EE04FE636A43B6B361AAD79CC24109EF67467EB103BB7812
C015B07B6EAA4931AF4A5A17D21AA88BD8E49C55BC1B68C60B75E2F3010CC15E
87B62128A632351389FA5027404BABEE9B38A41B2049FC77194A010CABC53339
E8CDF172B872311C783A8F2BE80B08E566A60552DBD6A302E6BDFFA20438F018
4647BFEFDFBEDBE6F43F03DE472E51A17BE5E15126B33BF5AF4E1F103C2633B7
00490B0A80D4017D254DA63E3238A20720FD33E8612F98D9EE77EF1D85FD8B55
0525B75CB9C781E37057DE0BC5B2799B4A6B62A9C9BBCF1FC02739A92CFBF928
7B75346C3864B99A0C16F468BE1E3146E3D9AFA65A8CC12079C24C6494788438
33534B15A83436BA56C74A835C5A785E9623F0D483091D6F95BE42F08E7628C1
10955C6FEDAE7B54D6D13B903D2FE2D30282A40A158E34950BA2906B425FE484
270855BC7372D1C0A0096056F9C9D4DB5C342277749E85C7BE53D7191ED68008
C670F6E70DBE10E747E1984A1C41D701E6220B001FEE27299AD32E960DE2CF2E
3C9CA94D43E219F06892F304B2F28C1A6B27CFE73425A804B4056AE560F15158
70E97093099D13B81C3904DF76D09C575A27CD28508B53AF4FC1700E8AC2E1EE
384B0F6907DA0232BF5153AD65735266A469A58C885C069419693DCFDAD036FA
15EAED8E593DFB8BC9991B1994C5D9B2E4DD1F6CB7CAD2C19DF0CE4A16581287
CA52C91C957F37ACD579854CD11DE167519DC406C943B14745C15A208A90BF33
46BB7DA1558902882DF30569D86C3FA13E9E9E4534AC2F079A5A88BE96F64B37
B48C6DAFB92FC1F21A4EC7894E2A0D724F4F3B1798A1A62A0A6F8E820ECB5FE4
ACA6A493180E0EE2B1612A9388E34CF39ACB4B8C228FEB68807EB097156E183F
D948C3B94CB7CD358CABBC7761458D882F528D2CC81C1EFD3262B711994EE781
5D92C1D6151D1ED960E0C9CD960C9757BA852F889293D91A1CAD3A4AE79D30E1
7EA33C5E7EBA96669D80EE6F3E05905CCA51B26401C192246CC6E5F85E045FE7
50DA4A9B403FD293CC436A63D2474C6A051E35ECA99C22F4BBFA0E2B0BAC8739
A74601FBBD715C131435EE885780EC50DFD4D90B568153D8A9DC804DFBA4D875
BCD1C5A160EB35A8EB174221DC5F5EE4AD49B5EE0AFE3B6468AA01ABC8EFFD9B
0B6F1C0565F62197B85088749F3CAFA40A6A3223D4CED495D6278A1CF417C173
43950F65DDD3206D4D9072461F7468F53B241CB9D6C81C4D965F85EA14F4839C
4D3ADAFAD7724AB33FFFB35AD715BB0DCDBB2D35B51730CB8CC9D4DFCCEFA1B8
658C35D8171F1114677D8A1792B270A46BBCEC94BDCD8A5E225D29D4532B042E
06EF181E6DA2EADEE53439E9ACB91AB3194C4AC87C2C0F7D5C198848DE88179E
97BC531F99999053013611B3230B8D462CB2090FADED0957B2A13CCC8B93FF7B
C5FC7C7A37AE0523EDF0C1160CEBC4F8E80A54D110435B8D61DFBDBE592A1152
43D103175D288DA1003B76C9A185EE6A8152A3119FF32343F82E3B5CDF9007D9
B8833335C407FAC26C11F9C6C5C3C3F9B01526D9D71A74984522CAFBAF6CD275
B5ECFC3211B599AD6036A73F47EB0137A2E7FA75593997A9F3C072940BA3ECFA
1C2AD0E4174917B2684EF827C03E812126F491688AB4FFC28B25F44AEF8261BB
77AFE3A5153FD948C3B94CB7CD358CABBC7761458D882F528D22DD037BEA807C
8DB15485BE5285E83600D55508E0082E0A7F579C8A4DD8D901A5B598D721639E
2A82FC866984E6EF069977E88971C070FBAE2C25A7104589EF38860AA565D3FA
F1703E3AA0E1EA27C9AE258A3823E734AAC37807F9F312AEAA53D1D80ACE9C3B
873F2050025DD1D944129333DDD269E32DEA342800BC71189749B5BF67EE0E40
D534E795EF9019F887473996793F6FC92DA11DFCB600EFA22290B3DC8113DB1B
383EC98F8367ECA28444115CC80D07137085C70F00B4AA2A3F38FE549D727B63
6F90C3EA5DDAC81A713A91EC4033F88EBEA6F5C4A248583DF95492E74983439A
B75BC7A21F225F83C46669A05BCC367A9EC6EE5FB3A93AA01DF86760FA5C65BF
5A0B64976205037F07C0E0FA630FE721725D8F5B0A803AF72FA82A3B2D14EA94
DA77871E3E5DB662E87168ACEB2FA1A315EA207D85667825E5DDCBCE0E191A76
07BE40952CA9DF542AB4A9C67F423536F0D04CA26CED51F1B2F263A2A9661DBB
A68175A656514425E96DD970D81D4DE370BD72698FF688E5524612DB78B0EABF
ABD3FCFF34780E646F79745A41552F95F74536C803FD0E67B1A003AD32ADA985
18DD604EFE6715F50897F075509F64E99E0DA3BDF5ADD237D911F846A5870C5C
77B675F10EF345BBFFC24C54A9A21E45428A97B9CBC8A1EAE07099B16063A9EE
60D6FB239685F5147CD3049BF8F3DC54D583F22EFF0DA12ABDF5C63C5B160282
3BBFC0C03B7A421A80C4891257891A08FAD24873CC2C75DA3473DAB2832336CE
4292B19F8D6DA3B137B76BFD5E32149937E5B2316F4FE916013D5C0DD01B294B
AB96A50CB449B6497FA6DF9BD9BF3D2514456D6EC34CA66C04BFA09E8706E8C9
45D2D4F4571771532737CAC4FE269D52662BDA70D70198BEF2C249D0492D0BFC
40D8DF6B9D4B8299B2399045A14D5429F184C1F36006E4DD60A05F12E3C18662
C3C134A5E9D61B1D07F60234951FF68AC24D6ADFE3D9C2D6FF02B71A4FCF52F3
2E017E9EB5E294B9559556A974B887C3C0457A9571B50DE69329014F218AB9F8
A7D45E5FC8759DC22134974E27D9D89CBC802B4A9D803BD635C05E171DBF417B
376266C585B6F3B17B1E23C26B4279C37D75AFDA4B5DD9ED6E3482283ACB506A
2D6812D4676F3EBC829C9546A7C7BA03C39E2B59B5BAB7C622F974A3DD980191
9A108CCF28ADD9B2582CF6C3178700E56D15B01CA4D3F3F15E77B3FF03CA99C8
67D2C9933AE39EC909022CFA530EDC774B5CF4BB6A1F73F9FA72DABD6F0BE023
586813FA42C53DC7E39ED5DF5D5B049F09A57296465F4449B7B4737AD52783C5
737C44F9E81FD417458090C00B56226A67462E3B609E0C07072F3F3E6FC8ACD5
27A075F80B793FA88EE3DB7788FBB28D6A6235824DDCA19F7B49E5CD6D40EBC4
4BE29E5C21F9C6476F02E285D9C32CCE4740F0AA61E1DFCE95DFCA2DADA7BFEA
7C740AAB7A7AD291C4F0BECF14318F0C968433143A19DAC00CE59BDA1FD2D967
EB9B7F6B389EE22D1C0802FACD28FFBEA6BBBEBB8F6F9C08B63E2A5E7428FC3C
A0C1BB2BF882F08D10D441ABFA40086967CF3CEDE338D376450FAAFEC5CA6111
D592F4184FABB849A3676A8D175D44E7180D8A1B67151184DB5FA0B27E7CE378
7FED70B0431D368E512E7C51C52741BF812CC89EAE94F1908928FA612C30ACF4
A99F6455C1680435B965ACFF8567327FCE6E1CFB635ABC8E80769A51F6D02061
86F857B2FB2F403BEBCAE7F7924AFEC7130DE52A490DD550A27325171953B66E
C5D0712B114BB44747C291F571D6E0ED8901F90F6F02D9F7356C311D84D4D071
C1465C95E05BD1F6B603AB0A2A956ABD52B5595B333A06C8EC4A42C6CD98A11C
F432C5E1F85F85012157E885ECE99C5F2947375222A66AE03BD8F3EDCF0B1F51
A01691E505DA03AB3799AC275B0C775BAD70526CF070783BC4AB150DD6BA5247
D7A252FA7FF5DBA665F885113CD2E239B65D0E985B783590ADFC0C5C3CF00E04
542DE83914234E64423B9D418C4403ADDAE724B15646DD2FDEA523D863CBD4EE
16455CEA2F92B671F7DA60566CAC0B6A193DCF574938B25FAA1E99569218CFA0
BD6F3615B632568E0EA67288F7AF12B0501DBFA74B2157ADDE421D5F51D813B5
77B8741B68891D6B7D753A182B0BAC8AB381658DF10814D8C2A0F73A01FC3707
2422F23B4F3088E7E62BBF4F829C4DE8EEAB740A9350956E25AC33EA5F2DB797
8E8581B39E56E5A0FD36953B63E6969C1A2E0A8226817F537D50344486533A0C
534FF2E613EC3AF9EECDF5BEA87E7C92105FC831839A0919ADB799ACF711607A
DA252DE7CDF57750DE134D101FF6343910D9FBB4225C1BAFF7CF3EC402F58A64
0ECFD22C0ECCA08F6B29876C079943A661301405160F9B3C4FE538113E5BC6BC
CBCE4D0F09A5DC24D41FDD14A9D535342E7802A5BF4C9235E28F5D93FD74122F
BE17C3B52D4DFC9F1A12A9E6EE68B394659A11BFC0ED3E34B04E664F8B47476E
4098ED693455F82F098F49FF48762C6CBE672751D8A658C45E07B9558E776E94
EC0991B31B7B1B399072B08EA7FD325496990FE31E58128CEB7E5B9B72ABFAD6
81F156FE238B89608E63C7EE1A84A1CC11A3713AF3A361467D0F4BDD30DBD016
65C86A6AFC2A734C4F0AEFC1EA268D4264FA4C353F3BFB7C57E0A3DEC90E9B24
8C6B8DEA57B9EABBB715C74BD161B6D57BCA6FFB4CCC25E6097A206C91089355
95DA856256A53561874B491719539A584A375CC8B9C4FDF77D301680CB83F8A4
33DCE6F520A16FEC6BC543657B58D17313B32AAD53A2009F2291FAA610FE8C4C
CD57A7A8C9F5071193E20D0DA2162D29F9FA78CDB32A0060FBE6744617685896
E8F6522AE89BCA5BD92B4A41EDF74BD6546A647368AB438F0E2BAF9CC5380390
D36BF31ECF83D795D880A41CF7E0F8714AE0B564BEBE2FF35ECC4DCCD14C3534
6631E7DC86A8C8F87AF276E8795C6CE1075574C306FDB23607B2FE118595C0B2
30144E5805C3362F459B92E5EDE495444A4B5CF90D1793F98D7EAE541772A11F
0A66805BE39297FDEDB2321F0A36B1B1C0E935AC84696C5AC192C394EAA0DCE1
80C8257A3ACC1122CE497D5BF45F0130493BD09689DD84408EEC4830380A6BD3
E210DCFC74F2D1B40960A87AFE63E91469DC77BFB5CEB75A3D6D2918ED85F68C
6C51F6431DE0F8FEB6C3091AFBCAEEC0FB3F3A4BD758049F48790B9A77DDAE72
2A0CEB31752B86F48C3078A5D7DEF679902FF59E3B86054DF5B3FDF838565D56
5AA749EAB7C6F6D76DD96C7795933CB7F3E7C1A59F05B6A29F76C95C2F8D3C3E
F4C1190B633B9866031EE8AC42DBB2FBC9AA65EA4FC141E32326604C59CA0161
24E1C2B0D14E85D92DFE733657BA7C2104003CE178CCD1AAD2F54B3850227D2F
6D538FEEBDD697C394F6F3B8BCBBB4C4A28780968331DEEC1A418382059D0ED7
0285DAB3B007DDED01318BC9A9C8A9E8D714B1A1D6BF89D4CD71DD3DC0B24BBE
34AD7B572EDF436436EB7FED0BABD23370E7003D92A42252C0BB59671471F7A6
2DE9A66C3265FFBBACA5055336EA2E3A55F05E65D826D0748FD49E09E939EB3C
7C9EAEB3D47348C47D928BC883B8E7606C3C7D562AE2A9B800166E14E49DF641
E5329F12B7A6E16345920621BEAF0DEA576E9734074DF497A0A78C62849B18F2
A035EB7BAD4A2236651359D3942F98C02657D436D4F21A7676678D879ED994F9
220B23631D60DD4F0171772F352CA74B5DAFA70C389BA8798B3CB383E4249CA3
0432701FB034E81220EDD744B8D4454554E52BC8DECD376F831A69254A546B6D
A8EECA492D56B2F9F55B323902D45EC3231BED6F014A7B7CE4D18AE1419122ED
10F2D94F7702F478B38C812123B3EFE57CCBA8C540B2E55C196B9EE8925F359E
C5BC402442BBA33B2663D56444B9C63FBC1B112A60ECC73EA9E5580A8247A328
55A2BA8F9A03D40585C0AB2F5ACE792F05368499B19687E504C3E3F79EBA25BB
CAA1C4F19C3E5DEB83811355CB98A218D7060B509D7BB71922BC9474D03BC93F
ED60C902138FB9B4F84C1AD48F8B63525AAF4BFD3B348D9AB2153CE0883DA64A
01E613315C7BABA40D366572F5DCE5751463D8FE8BC6D819708103BB963F6F0B
DA611B948CBEC9F8846E48AA27E36CFE86F2470322D955776E1B6C45314F5C90
9650BD9404BED91639395DB88CEF35A4B850666E4F53EEE73AD08E20791CDD3C
F827BA903093EB24996AB9603145A82BD558AACBE2337E87EEA5DC720C53EDD2
E3EA69D2C9016445144AC261E705AC31AE62DA3B30D6C19AE1DC90307A59EF91
2E6F92A414183F977187DCBD20A0C21706A33CCB741E91304FA287688FF87FBA
A44A1147008C871F77FE5B882AC9B443AF67DCE9D17E2BE28DD1960A12E9EC3C
63D5CFFD2BC79127EB92A645AA1AD7D247307FDF5269B44DAAA80E7B4DAD286C
0B446B09976B06C337BE0C2A552670B49F6EAD48DBA338B09BA3D306D8B55965
4D6768D9BCCC6B46D23288554515B8C047FF9A63EEB766D68A26681F75A165FB
9D0C92DE64EF1B93B3D5CCD1F60FD3DAC38663E410E0BF2F9D31410D17EDF703
BAA08D393AA0BAC2781D8B360E5AA4DB695AD2D13DECF2FAD9DBFD939B0DFEF5
275B9387723E2A0306AF0030ED0D0769FFA19112C97076BFF950438DC19E0E5B
DC3190C4CAC7F46D748B1FB871C97A78FE15CC07D035B5B88C188D46282036EF
183AC810D42A2265FD9F3E5E19AD1D5E5C5F47775A67C69A80416EDE8726673D
3152CD273D67E589DE38FFAD26376939CC85C4B8ACC2BD07DC6C0B52D99ECCF8
9764E3718CF5AAD7E227636641301B6535236B09184689D672FB302CDA74DB0C
41C39B6A5D843F40FE063935776459C824FA2F48C9A6451308A39A3D65A8CE04
E1583229836D0DD8CA390CFD14ED74752435B04A2885E1BF5F7660FCBD590ABB
A7581BCD0F417E9CD3E5580A9B0D04F36C41B2F6722187631009BCD2C9082CD5
F8B74D44AAAF83E4E04ACEA44C5BA804EF635ED9019232C234505B3958516375
03A6265C8D5574876F5A6555C04D0A86619FA46249868CE8429DD1D33E735BF1
C5976FB22AEF42D03E33DA209123B6E2B50FDC03658881A9C92C09B14BB2D87A
A395EF6E1C8A6D3AD53CE9B69E7A5D0E31726EC3BF9FD98C0AE5BA1BCEA2CDCE
892965D7D4CF9DB0F7ACF7CC00AD38CE90C43BB1B17F49393F76BA5CE298C125
9BA8F85961B560D845C438D8F26CF6173CB95EE29288F1DBF9A25B6D22FDF753
101FD57FBC1E6470FBE00FFFF6D3664C5D0355F8BF470BA8B17C7BED0D9F2022
5C3C204A716744D3D19D536F24327790BC6548427F7E1247C8419214AB037971
D494CE15FB214B82459C026B3A1226E7BF21558D70B556D6FF9D27CB74DB2CC2
63413888D1C4B8121EC2C5D4A717650ED4F0A5D956F69B4B2ECB5B720B5CEA5B
78ED3A71CB1D710393EFB379209FE16ED2175265D14F360C60B70C458D1BF0CC
8B22F37E95C27F2C40B30C552FF98028A141F53EFF9021D9D4C491F26BE8F54C
61165CAD7C83AC8931A2817EC3709EEAB74AA7AD3CB3BF89F4FE0E10F713BCB3
E17E0CE57CC25022A23E388B7E2CD22F1018060AF7B697A616F07AA95FC25807
B9C3C178662263630C3C9427AB5FF346430D60D8F895722E36DD2C2DB02111FF
D2A7F655409064EC92E4D0E7C706E4A4AAE9DE701E9AA2644EC087D61BD7F509
234968915C6A9FAB3D20B601611E70ED5E18C5897CA59F354BD2ECF30C6D9B43
95EDDD78DFF769BBC6250EAC584D3B5E88ADD1EDD80FE183E1D37D9BD147A2D7
C0D6183278FE8A4C3B7160D02BD1201C63D91450E7B5F44AEF32087A030D933A
95C305A5B17E3209DF9F81567747542BD1857B6F5060D5FF8FC18115E0E968F1
53DC61DEEB7273697AE8307A095789A64173BF894005FB893CBE5D859076B5AA
E8969630DD6C3FE47512F303857357F9004A87B2E9415DC4E2CE7173EFB24394
FA5C76CC0DC9DB83B6F549C06ADBF01C2C7A13C6FAB4BAF10C72A23626BF6849
FC82D5608F90FE125EBFB0D710C83BCF6A989C96E69E411AD2392CD4502004B3
A36C555F2853FF310996D457C4AE4F5A4DCC24075ED47DD6FE8909C387D8F02A
88FD24540AD718A5A5D7053A236404661DE55E772F5982E78CCADCFD0BD5B773
7D7C3EC5AF5AC51297E874A9A38D3DAD511EF5BF7D98219241C0DA67E5BEC040
A958B14BB3D7821512AEF6C2FFD235E47595EB6986213CCE3FE132472DDC7AF0
F22670B5D3780ECD1635CCE3A881E4A568FBBAAA0C95F3EE8EE1EDC4194F1012
D8BB958B6940681AEA50C6176AD5BA8483B5461933DC9EA69E5F28389E3A3A60
7ADD77F5A92C8149B0FA58B4F6101E49A6D4B8224C70E805A9D7D4E3FB13343F
286E505014A567733A950B86CD0BB7773609C70F69CB94D169B85A32C406E623
8C39A0AF3C8604F17B678AE6EB13C53D9A3B896762452E38AA290AE87635A06B
7C74B7991E9F8908B08E82821E5CF4F943B5A47F8AA0728D1E8B8600FE25B380
D2DFC3330A43C39D106F3BC09ED496BD9A79025A9683ABE4C7E6D576964725D0
1E66D56E0684FA4F2851E599B4B8304CF65116FF0DA887E39D1FFCBA9B1336D7
0BC262D165E9982336D43C680606DDBCC23EF80D9D69FDEEB18D4FA03F19B2E4
7B79290BAA734052AEFCAEF6AC0280E232C2C6F3DAFB89904AA737169B00CFE5
4FB18E1D3B530E8F76F06EA273E39AA72250F7528842FC37D91B86475F3CC19E
B43474D602FB6D02F57F18066ED53549CF9E7C3EF2551690035EDF5DEE6F02CD
D1781911E07C871BC80E60FD8FB0114FFE3B3A960D601FF23C0F633E2B853000
450928EF7EA87CECE176E0CA070806D551B4CED96A6E96328D22E9AF223B7EA0
64DFCCE952BD014A5E96679ABCFDFE5FEF8673DC54EF6509D02C6FEF286C526C
0195115FAA3D0724DC953E18E8C8355D66B32DF73B6BA4CDDB191A66E68A5913
31150CEE1B942E1D980784AFC692AE26737B16275E34C4A12FF4954AEA096798
EA53C8EC5D29E3B3BF8785F4A0B31D5E4AFB0CA6CCF02DD4DB74B1CD40D3F044
5040B8B7367611F1FCDCF3D6A1171138EB56513350583C1D9BA8EA11979142D5
C0853C4458189F912456B20BBCF3E88DF5F72416D00B614CF607EA7186B75426
1BABED2A22E2B93AB288FB5CC1701BE775C1F5D2A21749E38B857805AA0D7A91
1CFAE6CEC7CA222024CE0D3D63D31919B498D32C9487CE5089F7ED4D8217F1F0
DB37E3FCD95D193016C4CF81249AF3DD504B34BEBB4632F4D7E210E603772A7B
A6764A304F98143B209C374E832ABFBCF7BDB386F92A8661CE6E429DE0B3A612
D6CDE03DDBE795C43E8B807AB38A8553E4B5345123312D43AD2E836C46062F93
8B6566BD816C96D704A30F5494AE4D6997AD6BA126D048C4DFAF41B77E0C77F9
8BF02C1CFA6831E1F158326DE46CC1E57DD4B2A8821A8506BEF79EC52450BD63
E641E06972A5261CD7F6F20577E83176B2C8D0BDC532A065390AAFDBA137D3B3
0AE2D428B27933780414B986411241A1519E550B01053081BEADE92D2E498E88
FD4024CB096034B16EBDE16DA9FCBBEF79D2F6C4871C6DCFFF8B3878E006B431
7CC96B4B8D0416B09084BDD53179472B4FD84AF89FD2D62EC5E8E6EAA7034C36
28897D0CC4DB4B1BCA2E173331B899FADAF293D392EFF547FE020B755E0A5728
789F621D43A582CD7D58CC2059DD6D345EB02215E177CF4CB3D9FF1C49340CA7
DD41C4F4F494217D6BC32D638BBDACC51CF22379D24C2A0780333AB3CD383F86
07F749259471945843331BB382EFC1B0C415862918184BCC426C591BA22DF383
89D183D64EA6EB8BBF20DEB19596012837CA40EDBAAA2ACD2B44574480A077FB
B907A0FA8E38ACEB99E18BD1B2662AB55A70BE52BC811E1A329AB20B8A48A155
EBD50A5DC1919F4F11B8EED2EA76CBA0CDC05E45D59FF354E4F8EF78E7E551F5
BDDCE7E9DED0EDE562106998F7FBFA80DB76D4CEEFF78AA449BDE6B0707C1EE4
4CE7CEA7533E448A3A98D49377141FAAA54ECA22BA1A3D1CBE8B09C7296FF04A
711B3B129411BBB700EBA4B295B8DD50A21A3E754BA04ADD224693131364D61B
A14859F166BF131C078A92DCF48A540D1B46A430FAE1342D77896C1BD1C4BAF5
4C91AFBF84335230942D296E3BBCB4231674EECE12A1E10E7805DCF438CA770D
3297414ECD1FEF73532047FB1478F8554CC72457D00C01B8A20B93FD8A6C6511
665267B075C5D91DDA5ABE5B0927DE9B180AE76CE04F72FD54C0C9C05A9A9F2E
FBA1D488882701CB64B65683B497AE551D6FD8F70832FF440368D3B56EF16C51
A96E93E9986D0F4EE99587B3414B433A4AA8B8BC4B522DE3C4ACFE3F87F596F8
F02A2ED0A42248B3FCDD9946C80DD9FA6E39E6D581009B258B581941E759A7CA
7912DE02D67D3A8132670FC6F33F0EFF343B69F77A375F54FD59D010B9EC7590
C31F3D243AB6E8C41BC1DFF1366727148953187801CC5CD18FC784F3E7FFE8F2
DB95A11F5569A5E8EA1D48018A4D4D2B0BF2738325C89AB1AB15D47BE8A273A0
4C8F9210E9C4ECE00BD8D482DEF3BCE1091D857D5F50730F87461D819A7BC47B
0C34CB74B26303D8BC4B5F2B1EE5D4F933C3F3C08434FCDF4379F75315E5357D
578BC77495F199488361801513186F17E6ADAD32FAAF69F88DF39258334F14D7
B4B3B8371B59B12516816675EF303FE4F01F1F84DE922D6C72A089922A1A2AD0
610467E040A6399719FE1F2563A155D357596E3A2D629461953F256D85FFA25F
BAE4BF71A607396A0F81EE204F09E4ADBEDB1ED3AA9F1A7407A5C9794665E696
2C2F07C2E2AA8634A8296D4DA318A222AFD9BC977CD89F1453195AE7A90FA903
543B75006666BA27E1E24B2DD25FF9ABC7AF1AE703D9626796D6551DA74F593A
5890C80D014D56BD2216DF06B054E903A875CE4A11679A27E9C9D446FC9498F8
ACE916B57FF26248E4AAA1B286B9B566CFFD1C50E9BCD1885D95B60048D2EFAC
8D2CC25BCE042424855F4B53071DF5A0DA5A31B8AAF9FB4F493B2521D687B8FD
41367123CFEE10E02CC61C6E632B06EF13619B132D1D7DF3C37E35E2ADBABCAE
B14B34D2A68FE3DF23BF4F24B7AF9FB17AE13A2908129D592215A588274DFED7
A30C3CEE434832D290AAAFB6CA80087E819ED7B8CBCB49FD9FFD260F56CD6070
B916527529102E246B08C4D53EEB440910361E2E56BF53B36F3086EC723B2440
B40FE2F0786E979497CF2A3361B379302099EAEB2774D2226F568BA8A3E67EB3
452C5CC0ED8D059CD0344069084C46F9795641EF3F6005F3C00355E52AEC803B
EA28B1A347A6DE47C5FF27622AD08A33AE6C255C38FF6EB0315A92169AE858D3
975C73059DF8D9FCC459BB7F76E1C4F6C1838BFDFEBA9DDBFCD9023C35EC78BC
15294C3700C49E10091FAE714F63A24AA98A5781F2DA4396FB6D88D94B5C171A
294A2A8C263248327955365280ADC461AAB16B9DF176051ABB7C78512D6F34A8
4B9DBB50CB9F6E21CCB01746D41D1EC44BE55DF5BBD8D6B0FF4FE1FE82CD6AA6
9212F7C45DD001CDD50B27558998789ED55B400620E9AF4EE88CE2F79FFC9789
586711C651D98EAF3FC198A131023228625D17C0CA52B7166BBE85F9EC6F6528
1C6D23D511F2C11DDF3FAA6364C632C8D14882DF69931B83B3329DDDD044BD3C
3C36FABC9898C573CC83BDB2CAFF3EEE454AB8558EC865DEDF781D4A95DA6BD6
62FFAA0A6AE5778B2A1B72D012C9B0525B95884A9792703D498EB30FBE4BD9D8
99852DAAFE9B5D5B0BB5D08866A036F901A464DD4880F9F40FE635F58068781D
2FEAF7057213611FA533723F7576FE07C102026379A19C7CBA56DBB99E2CEB0F
7A54B87129A7365B3CE174D5700EBFBC14A70AEA561AAD24BCF1576FB299C35E
8071DF9C6A6CD59834A853BBD985B34755F069B7326463406DEC52715E496F70
50A16A6C62D6F124DE122BA6312C67719EE45655F1358FF0229FD08DFC5122B4
38A5A45E102C6D351853990FD81536DBBEE2ADCC6EA1599776559068020D41EA
A7F6C1A9B682B344B7DC94AAEDADF81BDE75AE81DD5C91B731F89E0191BF23AE
CED19F8E97B6381D949E2E806F56EE5F2956C660D58021CDA39292521305A76C
C4A6F6FABD063ACE8A01DC45383306CED38916B3A0886EC6B9E88EEF2F9405E6
DA8139686D99FA847E0F97394DCCF42E5DB57AEF5C1F15464D43E2A625CC71D1
1DE1DFC7E967F6DECA7277FCA73E841737D9AB7C145684BC394555FD48923639
33B9808632B44EEFAC9C69D8E3AC35C7C80840FCD2952FADD48C29D84F22C641
0E9FC3D02BFCE0E0283AFA949CE565D523C64848197AEB3F6C79358453B354CF
C94542F63A447C5DABAD4BB349EB478550D357992CBFBF2CE2833ABECAB32249
871871BD55E515F7FC9F4DE75B2CC3FCA7C38494AEB75615C7A8F64D13FDBD4F
B5AE98A4AFF73A01F966B13DEC5A5D7DDB8876A06FFBBBD35F531B4662BAD407
80F65DF7035403CA0F72E4CBC21733BDE3648FAB507680ACA37850B30D1BBCDD
128AC48359893725112B308CD62EC74FDFC7CA0F91818321B3EE726C661DEA44
7308EBC12D763FBD6503011ABA247A0AF3051EEC0D6D595F1BDEA4D2626A0AD6
3FC287C534288972EA8EFAE6C21D45FC95F4483FED80420E4BCD787F6C1979B6
528DA538E513B26906E9E6BC229D511F324E3295617118F041B7C7648602DD62
C32CDF44DD8E430DCB7638E2EE5C525E2C91A8525079B97D9FA6FE5B7DA4A263
813D3421C385BE62E6ECDE3EE487E2E4CCA729FF94C41CF4DA1B7DE56207EB2E
7480E1207329949BFAA4259A32E8582E4AEFBBA0F344D7EABE7118F71AC74257
4049DCA3013846F13666CE4476840B8938C7EAD7E49B3D8B81CA55D7C3A949C5
47B8A5CF52D9334892D6D548E3AEE8B73591E8F11832AC295BB1D4ECD9FE817B
07AA754B523DC2D91C4BC9EFA3BEE0D63E0DC4E6F253A60B2B187AAB2A610A43
4525B5D3F83B68A4A45F428997E2A731A4F36289D1712BA7193FB92D21BB87ED
788C589CB8815BB70CF0220D1D53AE3CC92C910CAC5922F6AFB148FCE2FD89E5
A5268BE5BB7602483A341A59A1B95EA285C94FA51F69B12B699A2FCA90DFB3DD
730D96D100DC5B1BBB12E0F5738600BFFAE3E467BEA9BBE6258A20D9E32E1746
C9FE36A429D872B158F05CA09E3C1D5333CBB2392C4A4BB159099654A5253D50
0F5E1B24EABA504C2D693906E471CE226E4770A2EC03A1CB6914E2B1948BADD1
B278A56D0DAEC5E72A96F5D5141AC86DE7E7BD90AE26553EBA84AC04C92477B4
FAB1037FB0997B367483D2C8C0D44E6111CEE2EDE81D986B3D714BFD49F6DBF0
306CED94DE945B5A67DB619AF949B0E4980653F01704F8963B8BF87DC9CA5CEB
0F755562998B379B066DCF4051E3A4CE8DF04768CC0B8365DD500A80ED96EFFA
1CF769F4A2A6DD033D6A0D6F7EB6FF82CC4E4AE64C608EEE0A2FA4E6E74BE7E3
358CC0B99B15A9BAF2BC4A47C0DA91237C04915BCFD8518FE278E98CFA10A67E
C1382813E02E7D39EBA812C50D0FE41B97771C1687BB8C208C8A4A69B76313CA
C04F35C0D781DE701498E8C8A4A3E8E2EDEB61B783E128C91C88AD1138EE7359
F27015787BA593BC0C6BA1BC382D228DFF4DBD3D26FD8D7C552C5FB55694647D
0F589FB14A53826E50E2B9EF955D402CFD581761BC87542C1FFFE3D4339E3524
88345BCA78F87907F1E6E32DE2FECF6C0E41EC2983BAB18CEA58D596BDED31A6
9CE0AE0177D2B99B9AF1239798DB5F75ED2150480DD677F5CCF1CEEE6354CDF9
A83DDCD78D676E71B6C51A64A87FD82AC7FD782FC689164B1A9B3C176A090A9F
6851FF9FF10CFE04F29AD6FA940714204D06B4D6749FC4B0B5C900A42D124B6A
B67C28340AE04616F5F1B3D1F087D2EBF1380AA0744E454FD99BEB430557CC18
8BD44FE265A2DC2A176462F529082DF93966CDDB526EA5A13EE3EFA361F9CAE4
64284925112FFF6E06D4095CAC5179C10AF28F2335EF156FCEAB9F03FA39177E
5FFF4A9205E20954906ACE661BF28B4BF93EE60C9B24D78DA80B72BC08668E39
1ADE6CA90A3989125BC27FB4A991C45634B477D3BB3732E514A7C1EB13EA8230
F0AF49C0A222FFE340112C6C063B2F982928664D35522EADAC9FFE1131374EB2
AADDB2337DBE19B72DD33B92A53D58C697C487E3C9F825B5BD086A6DB7E66590
93FD46A564338A191EC83CD5AD0E88F63568BDF0DC2FF0E40D5A3A2E5B7AF64A
3304B9E86E1BAFC67F88DB64E25ECE20563520ED678F0BFD966D7C9FA16AE8D3
50389A8E828A9574882240384386F6DD985C40B349208905711E015CA1115B60
CDC9EAD5BD6FE1808161238914AC473001A6EBC721B3AD347F9CC5C2A27C339B
E7E21C4688DAE073EEB636927885DF1D3AFF4BF6EE79FB8DFA754C9789DCD73B
C1DF740F437DF5F1B361E2AA5CD9DF5B7963E6EC917BC6FE271EE6C23FBF532A
DEE5E40FB84140F348449C01E851C4736321D6DFCE20133B827FBB5A970FE5E4
47B6F81571AFB71F8FAA0D71F810608E696F299A0821E42C97CC50E6C4D6C1AB
DAA045DE0A07991377B26AC761B1A938DB70C841821BEFA38DFA9EDA9A132955
A674C60D5774E77E0ED24E62F5A85DCA841463B040BE27F6F81FF57E44795B95
C4F710D25C2FB2BAC587EB24E08E0F489813FA67EFC52498D69E35CF7072A9FF
68417EA5330BC8A57E29AE4B9A561BBFCBE043A73CCED431350124E1BBD9029B
8D606999894716E7A31983CD63733CCDEF6DE2482A7DD4F335F756168F9F3797
C61CA81006BA2DA9DF1164062F545BE743C0CEAD8714DC88840B711A771548C1
1BFCD146DFF1E589904A48F2383B3319A212AC1141D5E0EEA2F21919F236967E
8B4199C0E216619BCE067CC1BAE1C8E075529DB21756488893EA46C5C9397942
013B540DD291372C1B05B285B7B653D90E146B6AAA318E165C8353C9CC1F0923
83D50675A49597413D95EA0463B1C428579113EAE37586EA5EFCED1CFDA18F88
CC3A80133FECBCCBC55A4DE35C770572F045B32289A2AE66CC44A1C13FB8BBD4
E180CB9349A614B3A72AA8FF7ABCAF66A87D91E95AF7AEE8A7DC6C6869674709
85AC22D7873925F1C44C359737834D420D4976695D2851ADFE75F0E8AAEAF174
FD8B2D55895E78207B139DEC9EAC296B7C4D043DAC22ACE46B4C731E2C61C6E9
6F276FC34D2809D0D8DF0356D99ED3DF741F61998ED4A65B374EE14ABD4D9064
245FD0D20795023487ABC3D34172433CC652E9B2516AD0EEC9F4521790D3698E
CBE3210D354EE0C9414A490786C04073D13EB660FF7247CE5236EB13B7F1E8A1
5AB9B0819C356919FB5AC0E53963712A6EAD0F218DAD2781926594A41198E5C5
6C33B4AA716C348026B4E784494517023CE9CEAEB530A43DDE5BB0252BEB0EF9
D8235977B315C6B061EBB74D7183CBE6414249A00134B04D9557145C824496B1
8402F96732A98009CAE553A317E908C6DA4596B2AAEA20267FCE91F39076EE06
BFD3C04FF933CE48AE61ED5C70D842AA66523FB8F1BD0C4E783952F977F27ED9
7507287EAF0EE46A887C53B1B7D289B8CDAE74EE3FC78C98C483E1F42DF06C8C
3B0209EA4903C10D598937DE1944F8D1EC0CDB28866065801AD16AFFFA989748
5FEE2F102ED510D8616D8EDA82DE6BA704B529D187450DB7C076532C11FDA4C8
18B0A3812B714D9025814369FE71C397392BAF4B8F10C50D3B5CC763A1912FA4
115BE17055D9E7F6A2F13C74F4AA95AB062740E852B137500A6F32D98739F069
81708E619B5116A10310B9B180DC2074E44C56F817748AA9B720742A415DAA0C
E1B8745736395AE8009B4977534D0E466F1FB5EF678E92F2BECE388E8464755F
E227BAC4EF115AB6116957DA97DDFA62CF9AC0CDBF3857FB3F215EC34D0BDA6B
DD5326FE66ECCCCC22EE7034B551AD5C83F6F34B1E87272E8AC300761CB99C9C
3640D38B1EF6BC34AE92E91E3DBF196F7BACD52EC4D756D2012DDFD2B4169ACB
7B7FC90ECE99FD80496C27169D141756F77E37143B2E58225D84934141A0CA89
69208B5470AACC410555B525925D9BEED7A3B4294B006D7C49E9F3DF1F701837
6F68D27AC36660F8B1F03444A2D3CB2A35BBFC367448EB7FE9D1349E90AB58CB
FAA79D58B2BBAD469C60E18A0CD50C7E937BF66AB171B95B61984B0200206F5C
1DFFE78F9FB4B79A06680D81C64C56F2706EAD544451DED49EC8F5DAACAB6360
82E7EFA02DC927135C98CB559929FD0D5E8A13520FA7BDB2C711E3B4DA8BD64F
181AC6D7355D4D5AA7DB63FEA574CBE1D26A142E3805F093A069196BAE8DB7E6
581F81C57C6E5CC9D3B29A31FC8DA5F4A317E7644446B44BB8012BCCAF8C5AA6
9A3A2A4B3708E7272F426F700148DD7894AB604B7D716A7F1428C5CC1E86F682
1160698242C7566FBFFC2C0A2EDC64B06481A32733AD834B294F36E3BE132251
A174CEE0AAB8449EFD258C8DAA3A6A5732A7CB0A03B71DF68E74F724DB01EC7E
67FC33903B7DDA3697D159B5DC7532947B97366718058835CEDB35DB4D7DF540
A0867D36EBE0F523F174D1B87F8E5A06CB2F03B396D8F5260CDE864B987097F4
47A890A1DCF9BB4FB519579E4D516FB8F7B9C94BF929F948962B0B053166481A
602CFA2B24E0F6BE77ADAD22FF83BD861FCD07E1302D6A3AC101BCFCD4977CB2
6F9A83AF7B4C5FF11863868BF0E582CA1D13BD7621152899F4B5FD24B0E8D03E
DE1D442961F604C4F48BA7137FECA0E57C7BDCB701639BCA947ED76A1324F5EB
442BF47047FF186B26AE1DCC2AA5081B915BC77F2959A1DA04A777B592888D38
EDE68FFB3EFE8380A17703F40F4E3D39ACE81E6816449AA859A9754CAD9C7BE5
C9B15F23045E29F807987F3637173FA779ECF224B8C7A24C713783B904595866
8C6F7FDA18A72D101380FA957E2D4D982E5FA720F57EC7DF7CF39EA825E6DD15
1BF74AF7616AA6256F36CB1B934FB804D3746F09FA12A1EF1955D84E8C1F13B0
0A8C20D3F5ABD19AA54CC564563C7F6AA5C76F8CE40F5E808B72AC57B638A927
E79612506CEE3CF1F861DA39BD3902A80E34B909D1F05E108DFE0A8C51191533
75AACBDCF866FB40B9BC1029A8782D21FC23A6431860622FA596A67132EB21BA
26AE3F51887FDA4D03F83E61AA7459C9F1467B8A68C2806AFA4A07EAECB5AFAB
E69FF4B9B2753C782FE9A59840A54C3F3EF0A73F233A093FA0BD5DCFEC68DCAC
37EA8D75FA68D44E0191396DB905E7593DA7A29CC61538DA34278CD2EEE94710
A648BC491CF056A840E564B7DD223804EBAC6FC1F5E7C1FF17A0D3F36EEE1C42
A75C01539515DC771AA9AF7760A03E0FDA34CE29D755C31CBDECBBB766E8B584
4B8235A5B39B62CE5E9DDC38F66DBB08539BFEA00B80A2DFC71CFC352E79202F
C3421361542577957E1ACCC9A7AFF4075A153273AA706F800093B52331A7C10A
F530845F39A5B65F474E0A2787011D33F9F076EBD6DC3E0B327DBA9FE6565E6A
DD1A0D1C4D58344AFFCE43F339E3DC27A988FB372EE80BF1F9AAFC3B23E0694F
71EEBC90953F9CDFB822FB9FFDC3588253A7E86AC486B73D53E7C41760CFB0AE
242F7A24F78ED1C4C76711D9E3067FB9A9CE4155EFC8826715DDA3EC572C2F8C
07763C538A011672B1FC1AA9ED610134F7D7
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: TeXGyreHeros-Italic
%!PS-AdobeFont-1.0: TeXGyreHeros-Italic 2.004
%%CreationDate: 30th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2007-2009 for TeX Gyre extensions by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS). Vietnamese characters were added by Han The Thanh.
% Supported by CSTUG, DANTE eV, GUST, NTG, TUG, and TUG India.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% See the MANIFEST-TeX-Gyre-Heros.txt and README-TeX-Gyre-Heros.txt
% files for the details. For the most recent version of this license see
% http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt or
% http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt
% This work has the LPPL maintenance status "maintained".
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-TeX-Gyre-Heros.txt file.
% ADL: 750 250 0
%%EndComments
FontDirectory/TeXGyreHeros-Italic known{/TeXGyreHeros-Italic findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2007-2009 for TeX Gyre extensions by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS). Vietnamese characters were added by Han The Thanh.)readonly def
/FullName(TeXGyreHeros-Italic)readonly def
/FamilyName(TeXGyreHeros)readonly def
/Weight(Regular)readonly def
/isFixedPitch false def
/ItalicAngle -12 def
/UnderlinePosition -127 def
/UnderlineThickness 50 def
end readonly def
/FontName /TeXGyreHeros-Italic def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-549 -284 1375 1126}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E5D071F743ACDAD8F4F97A172EEF96CD19C387
97118EE84B1DE73DCFB30C43A09CE2A3521E3342CD8A7EE63604BB81EE843F5D
6AD3646FF6B479C52FD0C9FC52E579D169DFECA886FF0E54E262A6CC059780B8
AC3CDCF49E906FDA76481CB5BDB1EE6DC02FAE8CC73018E1E2E4939FD7A448EE
DA1471E895A46A74FBE50DD2437045EDAAF6B897FF17840C6630BF05B8DC6F92
003B26446678D7710A21CAD232D205DAAD526A4CA68DE090E61467C524557432
8F50CCE2702AFC04FB0E58D28941B6C41608A1B2833C8558C229E2319A69436A
94F8914BF3E46710CD6C27A24CAEB3C59876C3541D8584BFA15EC6E4A9443E1B
23A15DAEB14B2DA0EE9980E8987FBA83E1FFFA4CBB5EFBD4E0BB4F1FBD54886E
AC080A0979C39C278004B846D352DCA56E7BAD590C3EA84A2F3F3A25BEBAD1A9
8C5744040DF9FCCDB0B67EA7E3BE6CD2DDBE1629CF3E34C45ACCC0150EFF67BD
73E66811B23CE4A8F29E92302F57C7947865183B11D169CC7CF2988049742DB1
5F5191986D29883DFE368B563A30D77E97ECE32DF6BBB186DD316917384AD15F
1D8205071B484C2C8A6681AE82D5A5E968E9DC5771D92AC2F8381EB6DD470B65
80A727E489AED1CDF0203B57F7586D06D79503A2F223F29F5CFC0796C0D2C268
01BBA99C8BE44409E1673697E5121992D9E95886E7900D8A1047FD3900CD639C
A2FC7D30F74D1428FB89E5CA8E4C564E908E5E1894B00DB996A5120CDA94D88A
1D571C3BCFF955534C6F564CD3E757B49F46247560F787605745609F813AD34C
616AF3579594AE94B25D7AB80A362267C266808208D4C6168C3FBCFE00BD919C
5BFCC9702E6981A2686AB6B853B898DF670E083263815A366816EEC7A678EEB0
AAA7FD294F0D4DCD2FA6CDE6A66100DBEA79B73BCA6A9FCF77F8A2A1698DDF03
47959A4DCCE3EF70F015EE2D7CE852DB07C015971B6ADD42AB0322B31EE02F50
F45804591F954EC902A43024D9C90EEF78F2511C21568ECAF12C86779188AD9D
53871027450BAA9A05DF9210BB0F60921EC03102148B03F0B16A40B392A20C30
1A0DB7BCC3743AD399C2E97679ACEA830AB446976308F06BB44BD95340B006A3
0A6C780B67E76CC1454771BE56D5B8C597A7E175B5B422414744779BD6DC57C8
AEF37D9872B22CD19ABFFC0468B2D448A840F4BE08C47F7D1C871BE42E5CEDA6
AFB08BED69072CE716CA34CE544502ABC9526DF48B0762B57F8AA965D0026672
F7DB32819E0900E7F90AE93A0D8A5319616751A5A80154B18B9919E7E1A053EA
F09141CA1FB7AC7E65D5A5D8C5FCFDB41707B035520A598564E61DB23032736B
224A9B0C456200949A01730C344D44A201EED8B4E96B5C199BD9CDAC6EA4107E
CB99669E392D15131D86F9DBD898FE9EEAB4E3C8B1BE433B73858600C7D9DC54
4694E25F259B039558DA35B72F5910268E28689F546805A26884C73258346B54
1871AE8346399477A2BFB3D7E65C04EE0553402D10D5AE65E37513CF5C9EE13C
B67BB0E76B366370BA0D967BF0167A6CA229FADA3E22B5FC343BDBBCEDA32C19
12D5221003750163EC9229A0C3D37CAB4DB8AF54AE5AC6D3B5746051A0E8E152
C99FF202141535564350F718EED93425742D97CC0F23FBC88F8CD4E4AC311E80
C6855C94FCC02CC2B21C06BE83AEA88DAF7292EC52D65125D8A189FBED43BFD6
030926C71F72B7A8DB8C8BF53AB40E03103A5A199CFC46CA3D96BE9DF375DEFD
070173D7AF2FFFDF728B7EB14228DDDDCFF0067C21ADAA911578E0CBDBC8FA20
43BDEB19CBF0774F200C2A29C34AE6255BC79B73AE14B980A7C3576BA329B39A
5588DF79D2E11306BEB7FB0A5BAE6D20F55DC5CC2218FB71DEE78BFE969B575A
7048B6086DCAD12E17F44D2828175BF383AD06F224BB9C8438B785C0D184E665
6CFE6D2A1A68C78C7A79A202BB5A041136CA99180509BF3AFB2171FE5A3E58B2
FB7817577248D8A696A7DC3322D57784BFA903DC5A829DB662C5A9FABE752916
7111B5E309EBADB7CEE9BCCA216C19D7F85B873D44B459B287CA34E6BEFF5127
9788C2BF2AEBE9A154B66363BAB6B2EEC169310617C44B7CF1F9155EBDF9AB2A
053F432A3149B7BA168CA488A7CCCD05EAD99CEEF4E3A931BD5EF07485FE4DB5
B47A2210DCBCA6456FE76D34AD5D4D314FCC538984EDC70EEAE90A5D8304CE37
D3D708FB4C197F972E2941C99376B5B59E416AD654E7057B937C6F1531F3CEEC
2B8C9A899AA25C2C92C8E401705B8508609A854BD22820CB6641C7DE5F26AB8F
C01951A22E97B68B3C6F7239B72A72EA85547426FB8DCA85CED8C179E8DA15A0
8AC70B44363C27DE6DF4AACB189CFC990D024A8719BFA0DAE4BF534FC07180E2
77C771BBC84A300794A6EC78660C06E7682033B4376512D85F65AD30E430DCA5
C980D725B3C0CA9868A1B4B066C40F22F2334343E1BF85758B4AA264F37E7F92
62FC8C671FB33550D3CEAFFF5053D505D1698DB2175A63130FCDF172B8113776
2894DCE14E8D9FC821612206DF767057302A95FBEBA161415478975E25D1E928
C5867A495F88565BA4650A43380708A59D6337736BA2184DA061F6AB3B2112C0
8D45B0926739D960D4614B51D997DA5811CD4110C81808DDE499B5BA7BE0A37E
B3D69F4B68CE7A5738306EE8AA00BBD282C6762F07FECA518F5985886A767EC0
6BC9FE94C5B89747B85F1D107E7FBEE52ADBA319828EB6E978C0D0DD1901FB57
909918D07EA763AC6CA06033F543ED44CA2702A5374368C306ABE140B6645B55
EAD0550D79E5E4655E10AE13C40486C060AEA89275D3947828C6A9675B8FBB5A
CFB75A80A169F1C6BDDD95BAB691BB29CFEA534319E195268F9BAD969385AD8A
B3B48C4FFD3D428036E074170F62339C2C4D4D5A6E66BAE16BA7764D8D8582DF
D200384EC13BB4905BEA0719B47CEE6133A69FD04AFC3342DA86F6CAC0A225B2
7791F6AACBD6B7E01D3C30B3D66BB08C9D5D4EFFD8613B50B2DF38EEF34AD0B0
5A9F13DD5786C2BDB0D1D481F6C7958033322676DD613C2702E1D64A6C6F6F0D
77282F434BAA79DD6B8B5699B56DE95D64C777FBCB70707F4F0F088114534F6D
36E4D3298309347BCB3C08C522B5705D78441901F4B7ADD6A0CF3F247852BA56
D5637DA0A204945533BCBDBA1B029DD6AA15B6DD86726F1107016FD88A03A679
E33BAD80476A0E2F3CA21869CC19CF9CD0F897F0E26E2DCDFFB37751AB5F9D5F
7E685C44F5AFAC1CC00F6CBD83D6FE5D06149532684067C78D1E6AE1F11BD1DF
31D7AAA394709221D78BA6858FBE3C3CE57006D90604D7BEC1CCD81D28BEDE22
CD263C60160BEC9FA8BABDF574FF5054D30C094FC54976CCF63D786E7A1D49B1
790EEE7E8463FFF7B0A03F7B5931AB2418F069ED5C1BF631B66355C40937313B
BFDFAE2F250B43DEAE7A752C6BC2F91D9E724CBBD53982E2FE82CF72A27FAA47
F5343A0CE0D06EB59CD75260255563C88D594B988E696DF1DF9B36FE935AC7ED
5FBCC24458251181278C2457B6F0EA299D0CFAA81A8BE845F00CF9C96E4763C7
E0AF90ECD2A3E0234F7E78504401627ACDC2F605CBE9A5935DFD15F5C181D685
3342FD9AAC09E00061C2CB2499F2B677D98E025393118B91A352BE08261DCD31
CCB7C0C7F7B5FBBFE76FF489DC229E9D6596E2F762FB6ED54CC9E41E6562CBB4
F3DF32AE56338C415D187AB30CE153914AF924F674813266AF9200C634DF12D2
DFA60982CBC90F930688C94329B65E14F8F11C296EF2D2D1E090052B8F9E29B4
FCE68B369DD4B8F89E6CCC1D40F78A28ECC992859F085A05262EC99DCC474159
5796DF2CC27F95B1392326CFE1BDF90BE6C46858AC7236A130C5BAA5744ECED5
515C36F2767E0D5894ED92C08F17FB8B81CB0B3A5D62AC570F0568F627D3CCD3
2E4B6170DEC3F342CE36CA69164ACA275EB64B46FA556FF6AD04D46529E9BC9A
1876241510BD0A48051A8AA4DE3EBFC3F6E2EC78B63B17C345827FF406499A2B
12B953D0AE1984D78EF2399E862A20F390797432F3B24CBCF51F4C14C18B1E51
46F69160486FDBAA76870828E5A3401A97F5DF6CE47CF745E42FF72114C9CF98
ACE7F8A4CB9C06F5A2CEDE9C68F323E4BEB08E8B77FE83EB160ECB4DDAC282C6
8500194FF7CDE9324E42E11A124CDA5D574307928A5F3DEDB431CA7087159FB7
10C91AFC97674F2843FB709E08E283462DDB1F1609F33F6BF4DB1217F996539D
799C1F2BA294679C8E06AA7FED4B8B1946C7CAEE37D8B823953AA248937D59F4
B92AA3FBFBE9BB816B42EDF445E9984AD71187BE7AC1C1EA6AD5BE0488684241
8EA1872BC169F92A890678704FF26E7A139EC8D793363A204193F78172FF911C
10C578EAE1774B790CB6222E108C959B8B1F730CEA3CF506BC8D5035FA46F719
B503CE4B2E2D3463B468EA89368E7BD6CF34EFB8455C231D0F83DA849DC65BBE
3920EA2085DEA18A90251F8BE10CC00A480EB1FB57CB36234C9D93CF571D31B9
7ADF9F19960B8AA81E1A6DA768E9993136ECC699EB8815ABFD76B252DA958829
F3C7D61F35DC228B86C23DF95F6CEA4642F2409E506EDBFE9AA18172EA581F3B
8F165270E90C727DB9E454670D51D7F880B7D37FD9F40D12C0D6DDD6E89A3BA6
468B6322EF1EDC173444EBC7FB4F3C9FFC8023DE1604FD41C754EA8685802CEE
1A78FBCD55AFD5FB30944EE4F182641F051985D776234852938403FAA5AD122C
B4A90F479AEB32B0C831C9F0CB8AC32CAA0E536D9125EDE6972EF5476A044B6D
7922685D87B84ECF255178D2D2C4B7F7857E7F55762D2C397E74A1FCD21E5789
A95CD7C2B2DD6A02320C9252B3B50E5204E612A84E61DA20F004DDB1EA743DEA
B4FC7262B5D90F48DA5BDB8D01BD0DF36D531892BB3AAFAB8CD95905FB83958C
19FE475DCA7075938672E207A2BC103F0F5AD372CD4F290E84611217ECA70B2B
6B818709B7255B2857A1A2DF3BAFC6F113BDC600A6FA40FCC21B1125787AB6AC
FF6967548E00ABF534D4380E4BBC0189BD98487988764781797E2E36F85B97FB
489A5D5A12D47544785EC754C8C57735031B7A58D1CC858BC7B4D312E5A6B535
FC4DB5D4AC148F5011054948A10FA9CA7D3D6D69038DA257DC2063A50DEA9C8C
D10A4D19ECD6F22A59E47DF9FBEA97DA04FB772797921FC7E416D29B19F4C383
0280F33CF486D55618FE6BBBBA1457A7B9AB98F76E5C882CDB6A03A7921BB9F8
5B93AC64F9C82C455E05D0DADC18411DFC4649C76F725697E699B40A3CA81F9E
F2215B2B0B1A7C67C3FEA42EB54F22E9A730AB8D4D5D3040117E6FC158723526
AD7C92DEDE350FE3E8BC93992D80794EA774CAD2ECA4581BD58ADB6AB154DAE7
957269491ED0063B799CDFEE8095FA36EB42FD653E6153FF2C263C8297C9E4EF
1E184E8C207262119E30EB5529BE403C6BD044D6F63233C4E83966F8B4B4C033
E07E8CBA7C127793DC4DFE03595BBF57B47B6B47F3619442925A206DBDEF48DC
E63F3F4869DA9D77CAEB4DC19B2086E891B96B38CBE9D36EB79E5D39574DE942
8C47AE870B21E75CD63D144DE465DD11AA26F59E2B12CA1CD88BD95F36244D8A
E9FFF3F592BB136F41F11AFA8CC986D7902F6FFEBE73A41DF6748D48720A0F63
EDBED52E7A45C7DE8C8B0AE500E89D1C1CB5ED9EA6FEED8611EE83825F14C536
72546AF3EDE43B35792D80CE15A6BEF1CE5811D05AF04E7136EF4E084C43A613
9EAD2930EE95ABAE64F18DB3F10988657C17162BA1A99670464FC59801746976
A05B3B3E96DF82E861E316A91438B567D535CA801B7070A4417404AEC1040C62
837132F24B4E513D791E8CBE69DF0AAA5A4BF65B0FA7D0BFE3869209CB0FF2A2
CAE89CD896F8E6E8FEB1113E961339770A3620A6D2192524C7067FA0E5D92923
6579DAD5A6BC105B8E6211C3F4C1B76C0CF51784DA23C2D29311C4F82514DCF2
7C6B94AA4F8BE1802D61128023A737F14760FC23ACF398BA02471B226D4929EE
7C9DC63EA8F9780763E889B13FB2BC0F992150FBCBB57A61678941A29AEA2386
CEEE705025E4C3C51BC3E784E53A157C5192135A7055198A6678913D0E2591E8
96938B584450D9E008CDD0202DB1B3CECFDF6C30433079988159D4FE0AD659F7
5DA3AC2A2BF8AB44095DF77B2944603F47BEFFD06259B256CD1A08F62A55334A
E7040D28E2027A98BF9148F4B1118179748A71164A0C54D49D520611165AAF37
11B005AD3DFBE56FD608D7EBE52F670153C12D459B6D919E9782026DC6A0B450
AAF945F0281B5A24CC391AE3E1616B5B5E4B670FA2BC64D7FD59BA1F9102D5A1
3492C763050D8E3ED64E59297C3A4D95D4D5188EBD111ADAF13004B95BB6A1F9
1E0A34182971A143737D515EC7EBDAB4AF1ECBA1C6E90B4B6726FC81BDA50FC3
126234044386036954E9BE82394B7893BA19E9B52F29C4A4A908677E90960652
8BCB2CC60D4001A032465003A5310E04016C3AE50698C63E30C2751FA0C386F5
0D2C9FC7F252AD669BB39A19492923F15CECF5CDC5C944756DF6511AE5914212
BA387D89E0A76B65FC2E3E2F572F339F48F22FBDB31B32E27C8600DD7695F1FE
F8041C8357BFC56893182C034354025F5404AAB4EF904FFEF935954AFB9BD204
1241B1BC8519EB6921C1425C9328C360FD1FFE12027F79F212F19C2A54F995DC
870ABBEA04BBABAA8BE01DB2E526AC429EE5BB7DD09C9B2F9CF07D450B0C05DC
94EA274219DDCE0C4FF0EA209B5AAE73A04E1194CDEBD673BD2C25E906446D35
CFCA31CE3807506FF35794D027CE342A66A4C27C0A4243D8AD0BAFCF511263B3
A79824A37390769F2EDD55DCB71F7BF097E4599421048329FB29BAE351A07AFD
98E1E4278F219307C670A0EC3C0082531B743058E2AC340C0B9077AE267FFB93
1B4DCC6D7122DFADAD09EA3A0EF203F2C695AEB08870DB22CBA2D2D284F09826
DAF8507BCAD3A71BA2D3F48A9951FD6B2822789384F7D9EE82641B2F9D76CEFF
EF39857DA6CE0F074DF55E0355AA31705F62B0E0C454C8C57735031B7A58D1CC
858BC7B4D3189EC47C7C4C9C8FA62A078F4F1683F37E5F7B8FBF22416095FA79
F354B447141CD77CD1AD6B8D17AFDDDF8365C942CE42FFB593697B786ECFEA32
0CD49838B5DAD1C03476F41FEC04B5C12B40DD1B386D89AD8616B4153F926EB6
C6D9888690D7D2C56568F77049927852E3D9856F9732F4F4AEEF704A5E8F6E9A
D1631F9E304203D297A25E558E6D4766165D19889DCDA2AACFFE7F848D35BB3D
FF27698E2316852222C1C8FFB4B6B3CB02A3A4A602010FA75E44FD7F6BA76157
167A214F11C228BB1F1320431F167FFB8DA6D0FC305210268A94F787E3E726E2
3A7E16D84E223D306718D250574E4602EC0964E1E28AF02750943BFD0868FBCA
FC4DE907FFCD365F3CD9235704BFFC7C7667A58DE4AB7B8519C0DF7B5A381FF8
E1C16308A97E5E21F91A0181155AAE4A63F71D9E321AC3767A901D90A040F61B
AF86BE97F8DAA8326EB1A2B45114257BD8410396D179DA4C1E7F5C7BE4EFF59D
55B381ED8045956CC74252718CC5E605CD6C3C5A46E851536CDDCB0D27E50B6D
68148DE8830830C374D6FD6BC149DE1D1C16BDBE49F32A57A4764E0C948034D9
0F8FB896D5153BD6E1D88D4E27E5EDFBCEC126CD722AADA6DB8732764FEC4928
827057BB3F9495AF32699904D4229F797E793C0958F9849D5B7ED1DAC77D33CA
607154E6B8741330E31B8BEA67970A39F150893C460EDABD875702C05640EACD
A10885282382FB1854E2317ABB61D9F28207671D79326F04D1CE34CCCF4CFC65
5DB5818840D39D041B26E253815433D845EC970C7711DDE28B2A220EEEA74FED
FB2620849DA765FFDCAAD86026AE6BF312CDF423D6EDA89BBE65B949D87043C4
686B22B16B2F73C307D1F7291A9E98B68CEAF2FB34EF087320F134579D9E18D1
E0A10E55BF530E9EF89383C06A6EFE56864309B5EC0B155006D196997A59EF5F
44F78CFF4C853337C6989ACF9F98AD4746CD1E349C20E9D18BD94E4265D0C876
0A9656E0406824D9A5930533FFBFA7D3873F8ACB0692B310ACA0D812FB0603D9
1737AAD98092CA8D7DA7CD664AEB24C9696FCF3CD09F534B07AB5996711300B4
E28756F69F8B63186D163F4D72FAF2D79EC8F4D4BF3D849D27EBDB2B26B37D29
8E5E300A394A9E1DD257A096A966C527C855E3C862AEF9D1AF88BF14CB44C210
BF44141C72291EBB1610B076D293489BB97B6DF215204753DE7C4A3FE2B2C5CE
1AF03A41B814B8DDE80D46AEB4F109FC99CBF5AC68FD3CE6C8B3B0AC0E75AE86
46784B588CE0DE89BEE5E650E65B1DB4FF453E0A10379F29FDA2F3217D0EA077
2E3B78CAFE3F27CFCB8FB95970989532011E12FEA1EDCEFFCB59CD95FEDFB910
B6371422CDD07263005CD5709989DE6EBBBAED8A49B82FF79AC6EB0B36E2F479
4FF8D215BABC73EBA052FAA5311407ADDD4BDB10613A860B10D3F40514F88E8F
D48F0B675F296A83AC1938FCE2DF98EE0C770CA00FD02267EAF68823BFE0AA2F
D9ECA512FAFF0E6B33B5418F210BACAA8CCC7D60AF299F7A6109C3127FB82A56
592F27FC27F1D49D5FF4BBC0E16231807FEB13ACD2549A8AE864481D4F76BB94
1B1832E3FDBFA4EED9E51854B1DF79823A500DFAC8646CB7E1197EE9CEF80DDE
FE0B9279975DC15BC1DB4D67B315C4556EA67B299A5DABEE0776B1A98FC2D040
C14DD87114A9B084D06B00EBDD7A96133B2E41002B812F8E1AE5C8B8A9DDBC61
3839DA4FCC849CEB3A4F4C4C1923F2E29BEC3089D23A88D1978B6BA40D5F8F12
BED3969657670228721A61993CC1FE52D8A57D79602D65BBA312E072096DC257
6BD7AB73AB3EAB6060F37CA8DF33446E877BCE976680AC31E00F13F2CA6C2035
2FDFD48E76C5737253FB5D2AE318EAF30905CAAAB4FFD115846BF98CD6DD8CC1
0E123718D82BE1E435043FE03050AC7BDCB219499738157FF7BD4CC5368C977D
4BEBCE7AAD6ABCEB874D8071ABD4C84741E7ACC6710BE72189808660902A72A1
7AC233949BD6CEF738AB415B034B567F367CA2E2A8AB4936EA7B2598561808E5
0151C166892AA2415303D2ABD61EAD6A453368C1A409995849AE4ECE1648C074
60ECCF0CBBBC56A78CEE3A4373691772A120BEE77098BB898BAD217490ECD913
DE0E31E5E08B89B0E3941460CCB0AA4CE5F709E096A9F5A23A3CE8A015130A0F
B817DE38359C63DB264462D050ED7C5513B0E7960D957E19837FD227B352EF06
17E262F020AC43AC01DB8BD67102E1322FD08D6A1FD81B7A051B9D7580B45EE7
6F2C097B3D9123E213615F53F674292909EE79FE294598B8493F9991DE93CAFE
CF760EDB4DDD3E54A6FC00F6B83D33DAA908377AA57FA250C4ED54F04C160CA0
742BF506733CF1C3EE17F2E7C135D9DDD3E0EA1BC88E523099196F039EB567BF
B06BBFBE9171FDCDC0F19C8D0285CBCE07513C22253B97539EF0AEC94258EA01
6A586610F633947FFAA9702E5BE4EF73784247FC0D40A2C3CD57E796482600AA
5E73A63B57B037AFFB084C8D099A75D89D6A89E962E01BCEE4B41F3F1C342A80
19FC952FF8D47D723DCAE7E031BC6CAA61F81D5FCE4783729578878D2C9CC4DE
CF246DFCBBD6E7E5708FE62CC19143732487FB28A99C314DD32EC802120562B1
4596130968AFB5284AA776CDC3942819204B37D30EF1B3DA27604A975C2DB6FC
1854457C67C54DC08C8BC3E8E27CF34B972AD10DFD269E762E83D1FAF55AAADD
5630E4D7BF1E656CF55B9F5AEA07AC8015D417881801B9D3F33E0E13DEC23F36
7F3CDAADB9A370228BDD7123EFCB5DA1D8CFD55EB82E0C85A089269EDD6833F4
E71F6F4B355E9E71CAAF5A17D5598D8E8BB772EF73E44BD632042B5D49A971F1
25238DE14F4F908066D56D63BA3D499E2DFE707DB05C0FA723D9E430A779CF89
0239F2A00C4E797EF349A0EB76D9524D9345E8226E83D3291DB86A056405F109
4AFB2137E531F829BC2AEDC874B4CB55D8438F54353D1245ED78D1614CC69764
EA424047A066C80757DD30639113DA11A98FB90364F008A13B111554FED7C4C4
305B192D25B4CCB9A9D05281EED29F7F78A026EEE764D9AF9DD776179C1F610A
95C6BAF7DACADF4419557E34D6F3B792A1257B9FF5EB18BB80A6425EBDAF6563
77E02A43FDBC78E4627ED79B16862D939F3A3631418D69CCFBFE7E3062895E70
6E20DE8096399754FB35F083F2A858182EFCF99114F384B2D69C75A42B747D48
5F9E8FC7A7ED3D99BC762576D38886EBFD84A70D91754E479F700980BA6F10E8
B532CD0D4E6630A68D7D5CD69B75B5727D400344644D0C16A555C50F6826750E
2E771E1B15432E1514664240BA7C78226D4E8ECC5B15ECC145F938AAF88CB18C
FF74FC89AE9A0B32ECDFD0BF913ED8F900090A037EE1DAF46C232601AFD3FAD2
38103E1434EA8F648222DF87570F4CB1612BEFA1CB71BC1CFA2278C41E3A930F
7D96A3F7CBBAAD1697059C16BEC49EEE8017D35E25BE199A9AB7892E680A2360
3F2267173825CFC9A04CDB15B160C3E2B285BBCFE14C06C49018548D5E875BC4
6F1E7A5199DAE7BC7EEB4C5C451EDAB35ADC0BC2700ED881E74EA9E1D0FD74C4
59D1F1662445F14CC1BC235DE87B1FF6DBD93F01F4F3989D8141816C34812C92
259BFA985C84CE1C990C7E6582F2649DBDBEDB6D04983E300EE9A5BF4E928004
BD90C2FCDFB6DD8952B14050BB7006B4F65699D9E45E323C65C3D953D33B66D5
0FF4423FE21D4D2625E646CE72588478BF941F1F7646EFE42DAC8806F28F4191
E7D48C94F67BFD060EE61BF36762EC05DC67AF67232A2371EBFF491E2D65D134
1B2C29758C492FDB6ADC6CB77EFC558FED519FE37ED52EBD380A21B97048A76C
810896EE34F744281F9BEE0D8F8DB668FBE43D456399B46BC7DD53C880D0132E
B177CA691AAAE751E8DEDA23D3F35ED0627D0189C677703575B84A1568989676
60E026B31EB1C95BBFFA540E65DC268FAAB4F4B27E2E69DB40F9BF5783565884
B338950A318A4A9B7B9B1C4706EF46CDF0CB9B24DF1B26000DCF216224075204
BE7E4ABD0323E6C7C5BDBDD5A4A72DE7D40E955FEB1D09F31DEF5EE5F129F220
897CB9537BD43AB0267ED6BA81C7972596EFCA4B6C94FB59AA727E5350B76A1A
74CACEDC4819AD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600
(cie_axis_H360_cyl_sans_360_ccw.dvi)
@start /Fa 198[46 46 46 46 46 46 46 46 46 46 48[{ encqec ReEncodeFont }
10 83.022 /TeXGyreHeros-Regular rf /Fb 183[72 72[{ encqec ReEncodeFont }
1 99.6264 /TeXGyreHeros-Italic rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop
0 0 0 0 34732544 0 34732544
 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 345. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -210.78613 } PutCoor PutBegin  end
 2200 -2200 a 0.5 TeXcolorgray
-36 w Fb(H)p Black 2200 -2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  0.0 0.0 /y ED /x ED /r 96.35938
def /c 57.2957 r Div def /angleA 0. 0.0 c mul 2 div add def /angleB
360. 0.0 c mul 2 div sub def /angleAtoB angleB angleA gt { true }{
false } ifelse def x y r angleA angleB arc  gsave 2.0 SLW 0.5  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 30. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end
 2200 -2200 a 0.5 TeXcolorgray -46 w Fa(30)p Black
2200 -2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 60. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end
 2200 -2200 a 0.5 TeXcolorgray -46 w Fa(60)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 90. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -46 w Fa(90)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 120. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(120)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 150. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(150)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 180. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(180)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 210. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(210)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 240. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(240)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 270. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(270)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 300. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(300)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 330. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  { 0.0 -111.41553 } PutCoor PutBegin  end

2200 -2200 a 0.5 TeXcolorgray -69 w Fa(330)p Black 2200
-2200 a
tx@Dict begin  PutEnd  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200
a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 0. dup cos /cosA ED
sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA def
/ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 30. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 60. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 90. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 120. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 150. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 180. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 210. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 240. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 270. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200
-2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 300. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a 2200 -2200 a
tx@Dict begin  gsave { 0.0 0.0 /yRot ED /xRot ED 330. dup cos /cosA
ED sin /sinA ED /ax cosA def /by sinA def /cx sinA neg def /dy cosA
def /ex xRot cosA mul neg xRot add yRot sinA mul add def /fy xRot sinA
mul neg yRot add yRot cosA mul sub def [ax by cx dy ex fy] concat }
 tx@3Ddict begin TMChange end  end
 2200 -2200 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.5 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 99.3706 0.0 93.34814  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.5 SLW 0.5  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2200 -2200 a
tx@Dict begin   tx@3Ddict begin TMRestore end grestore  end
 2200 -2200 a eop
end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
